<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure URL Editor</title>
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; base-uri 'none'; form-action 'none'; object-src 'none'; connect-src 'none'; img-src 'self' data:; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; worker-src 'self' blob:; manifest-src 'self'">
    <link rel="manifest" href="manifest.webmanifest">
    <meta name="theme-color" content="#6c5ce7">
    <link rel="apple-touch-icon" href="icon.svg">
    <link rel="icon" type="image/svg+xml" href="icon.svg">
    <style>
        :root { 
            --bg: #fff; --text: #333; --accent: #6c5ce7; --sec: #4b4b4b; --status-bg: #f8f9fa; --border: #ddd;
            --header-text: #fff; --header-bg: var(--accent);
        }
        @media (prefers-color-scheme: dark) {
            :root { --bg: #1a1a1a; --text: #e0e0e0; --sec: #888; --status-bg: #2d2d2d; --border: #444; }
        }
        
        body { margin: 0; display: flex; flex-direction: column; height: 100vh; font-family: system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text); }
        header { display: flex; flex-direction: column; padding: 10px 20px; background: var(--header-bg); border-bottom: 1px solid rgba(0,0,0,0.1); gap: 10px; color: var(--header-text); position: relative; }
        
        #header-top { display: flex; align-items: center; width: 100%; gap: 15px; }
        #info-bar { display: flex; gap: 15px; align-items: center; }
        
        .collapsed .controls, .collapsed .btn-group { display: none; }
        
        #burger-btn { background: transparent; border: none; font-size: 20px; padding: 5px; min-width: auto; height: auto; order: -1; }
        
        #editor { flex: 1; padding: 25px; border: none; outline: none; font-size: 18px; line-height: 1.6; background: transparent; color: inherit; resize: none; }
        
        .controls, .btn-group { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        
        button { 
            min-width: 40px; height: 40px; border: none; padding: 4px; border-radius: 4px; cursor: pointer; 
            font-size: 16px; font-weight: bold; transition: background 0.2s, transform 0.1s; color: white; 
            display: flex; align-items: center; justify-content: center; background: rgba(255,255,255,0.15); 
        }
        button:hover { background: rgba(255,255,255,0.25); }
        button:active { transform: scale(0.95); }
        
        .status, .char-count { font-size: 14px; color: rgba(255,255,255,0.9); line-height: 1.2; }
        .char-count { opacity: 0.7; }
        .input-wrapper { position: relative; display: flex; align-items: center; }
        .strength-meter { 
            position: absolute; 
            bottom: -2px; 
            left: 5px; 
            right: 5px; 
            height: 2px; 
            background: transparent; 
            border-radius: 2px; 
            overflow: hidden; 
        }
        .strength-bar { height: 100%; width: 0; transition: width 0.3s, background 0.3s; }
        
        input#key-input { 
            background: rgba(255,255,255,0.1); 
            color: white; 
            border: 1px solid rgba(255,255,255,0.2); 
            padding: 5px 35px 5px 10px; 
            border-radius: 4px; 
            font-size: 14px; 
            width: 160px; 
            height: 40px;
            box-sizing: border-box;
            transition: all 0.3s;
            outline: none;
        }
        input#key-input::placeholder { color: rgba(255,255,255,0.6); }
        input#key-input:focus {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.4);
        }
        
        .sr-only { display: none; }
        #main-container { flex: 1; display: flex; overflow: hidden; position: relative; }
        #close-find-btn { background: transparent; color: var(--text); font-size: 18px; }

        /* Emoji Picker */
        .emoji-wrapper { position: relative; }
        #emoji-popover {
            display: none; position: absolute; top: 100%; left: 0; background: var(--bg); border: 1px solid var(--border);
            border-radius: 8px; padding: 10px; grid-template-columns: repeat(6, 40px); gap: 5px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 100; margin-top: 5px;
        }
        #emoji-popover.show { display: grid; }
        .emoji-item { font-size: 24px; cursor: pointer; border-radius: 4px; background: transparent; border: none; transition: background 0.2s; width: 40px; height: 40px; color: var(--text); }
        .emoji-item:hover { background: var(--status-bg); transform: scale(1.1); }
        
        @media (max-width: 600px) {
            #emoji-popover { position: fixed; top: auto; bottom: 0; left: 0; right: 0; width: 100%; border-radius: 12px 12px 0 0; padding: 15px; grid-template-columns: repeat(auto-fill, minmax(45px, 1fr)); border-top: 1px solid var(--border); }
        }

        #toggle-pass { position: absolute; right: 0; width: 30px; background: transparent !important; border: none; color: inherit !important; font-size: 14px; z-index: 10; }

        /* Find & Replace Bar */
        #find-replace-bar { display: flex; align-items: center; padding: 8px 20px; background: var(--status-bg); border-bottom: 1px solid var(--border); gap: 10px; flex-wrap: wrap; }
        #find-replace-bar.hidden { display: none; }
        #find-replace-bar input { padding: 6px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text); font-size: 14px; flex: 1; min-width: 80px; }
        #find-replace-bar button { padding: 6px 10px; font-size: 14px; white-space: nowrap; }
    </style>
</head>
<body>

<header id="header">
     <div id="header-top">
         <button id="burger-btn" title="Toggle Menu" aria-label="Toggle Menu">‚úï</button>
         <div class="controls">
             <form class="input-wrapper">
                 <input type="text" name="username" value="SecrEdit User" autocomplete="username" class="sr-only" aria-hidden="true">
                 <input type="password" id="key-input" placeholder="Secret key..." title="Encryption password" autocomplete="new-password">
                 <div class="strength-meter"><div id="strength-bar" class="strength-bar"></div></div>
                 <button id="toggle-pass" title="Show/Hide password" type="button" aria-label="Toggle Password Visibility">üëÅÔ∏è</button>
             </form>
         </div>
         <div id="info-bar">
             <span class="status" id="status">Ready</span>
             <span class="char-count" id="char-count">0 chars</span>
             <span class="char-count" id="url-count" title="URL length (Browser limits: ~2k-8k)">URL: 0</span>
         </div>
     </div>
     <div class="btn-group">
        <div class="emoji-wrapper">
            <button id="emoji-btn" title="Insert emoji" type="button" aria-label="Open Emoji Picker">üòä</button>
            <div id="emoji-popover"></div>
        </div>
        <button id="clearBtn" title="New document" aria-label="New Document">üìÑ</button>
        <button id="exportBtn" title="Download encrypted file (.secredit)" aria-label="Export File">üíæ</button>
        <button id="importBtn" title="Open encrypted file (.secredit)" aria-label="Import File">üìÇ</button>
        <button id="copySecretBtn" title="Copy URL" aria-label="Copy URL">üîó</button>
        <button id="copyTextBtn" title="Copy text to clipboard" aria-label="Copy Text">üìë</button>
        <button id="pasteBtn" title="Paste text from clipboard" aria-label="Paste Text">üìã</button>
        <button id="findBtn" title="Find and Replace" aria-label="Find and Replace">üîç</button>
    </div>
</header>

<div id="find-replace-bar" class="hidden">
    <input id="find-input" placeholder="Find..." autocomplete="off">
    <input id="replace-input" placeholder="Replace..." autocomplete="off">
    <button id="find-next-btn" title="Find Next">‚¨áÔ∏è</button>
    <button id="replace-btn" title="Replace Current">Replace</button>
    <button id="replace-all-btn" title="Replace All">All</button>
    <button id="close-find-btn" title="Close">‚úï</button>
</div>

<div id="main-container">
     <textarea id="editor" placeholder="Entered text will be encrypted and saved in the URL using the key above."></textarea>
 </div>

<script>
    if (window.top !== window.self) {
        try {
            window.top.location.href = window.self.location.href;
        } catch {
            document.body.style.display = 'none';
        }
    }
    const $ = id => document.getElementById(id);
    const header = $('header'), burgerBtn = $('burger-btn'), editor = $('editor'), status = $('status'), charCount = $('char-count'), urlCount = $('url-count'), keyInput = $('key-input'), strengthBar = $('strength-bar'), togglePass = $('toggle-pass'), emojiBtn = $('emoji-btn'), emojiPopover = $('emoji-popover'), exportBtn = $('exportBtn'), importBtn = $('importBtn'), findBtn = $('findBtn'), pasteBtn = $('pasteBtn'), copyTextBtn = $('copyTextBtn'), copySecretBtn = $('copySecretBtn'), clearBtn = $('clearBtn');
    // --- UI Logic ---
    burgerBtn.onclick = () => {
        header.classList.toggle('collapsed');
        burgerBtn.innerText = header.classList.contains('collapsed') ? '‚ò∞' : '‚úï';
    };

     const KDF_ITERATIONS = 600000;

    // --- Crypto Worker ---
    const workerCode = `
        const toB64 = b => {
            const bytes = new Uint8Array(b);
            let binary = '';
            const chunkSize = 0x8000;
            for (let i = 0; i < bytes.length; i += chunkSize) {
                binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
            }
            return btoa(binary).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');
        };
        const fromB64 = s => Uint8Array.from(atob(s.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0)).buffer;
        async function deriveKey(pw, salt, iterations) {
            const mat = await crypto.subtle.importKey("raw", new TextEncoder().encode(pw), "PBKDF2", false, ["deriveKey"]);
            return crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations, hash: "SHA-256" }, mat, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
        }
        async function compress(data, method) {
            const stream = new Blob([data]).stream().pipeThrough(method === 'zip' ? new CompressionStream('gzip') : new DecompressionStream('gzip'));
            return method === 'zip' ? new Uint8Array(await new Response(stream).arrayBuffer()) : new TextDecoder().decode(await new Response(stream).arrayBuffer());
        }
        self.onmessage = async ({ data: { type, text, password, data, iterations, id } }) => {
            try {
                if (type === 'encrypt') {
                    const salt = crypto.getRandomValues(new Uint8Array(16)), iv = crypto.getRandomValues(new Uint8Array(12));
                    const key = await deriveKey(password, salt, iterations);
                    const enc = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, await compress(new TextEncoder().encode(text), 'zip'));
                    const res = new Uint8Array(salt.length + iv.length + enc.byteLength);
                    res.set(salt); res.set(iv, 16); res.set(new Uint8Array(enc), 28);
                    self.postMessage({ id, result: toB64(res) });
                } else {
                    const buf = new Uint8Array(fromB64(data));
                    if (buf.length < 28) throw new Error("Invalid data");
                    const salt = buf.slice(0, 16);
                    const iv = buf.slice(16, 28);
                    const key = await deriveKey(password, salt, iterations);
                    const dec = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, buf.slice(28));
                    self.postMessage({ id, result: await compress(dec, 'unzip') });
                }
            } catch (e) { self.postMessage({ id, error: "Operation failed" }); }
        };
    `;

    let worker, requestId = 0;
    const pending = new Map();
    const initWorker = () => {
        worker?.terminate();
        worker = new Worker(URL.createObjectURL(new Blob([workerCode], { type: 'text/javascript' })));
        worker.onmessage = ({ data: { id, result, error } }) => {
            if (!pending.has(id)) return;
            const { resolve, reject, timeout } = pending.get(id);
            clearTimeout(timeout); pending.delete(id);
            error ? reject(error) : resolve(result);
        };
        worker.onerror = () => initWorker();
    };
    initWorker();

    const callWorker = msg => new Promise((resolve, reject) => {
        const id = requestId++, timeout = setTimeout(() => (pending.delete(id), reject("Timeout")), 10000);
        pending.set(id, { resolve, reject, timeout });
        worker.postMessage({ ...msg, id });
    });

    const PLAINTEXT_PREFIX = 'p:';
    const toB64UrlBytes = (bytes) => {
        let binary = '';
        const chunkSize = 0x8000;
        for (let i = 0; i < bytes.length; i += chunkSize) {
            binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
        }
        return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    };
    const fromB64UrlToBytes = (s) => Uint8Array.from(atob(s.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0));
    const gzipBytes = async (bytes) => {
        const stream = new Blob([bytes]).stream().pipeThrough(new CompressionStream('gzip'));
        return new Uint8Array(await new Response(stream).arrayBuffer());
    };
    const gunzipToText = async (bytes) => {
        const stream = new Blob([bytes]).stream().pipeThrough(new DecompressionStream('gzip'));
        return new TextDecoder().decode(await new Response(stream).arrayBuffer());
    };
    const encodePlaintextForHash = async (text) => `${PLAINTEXT_PREFIX}${toB64UrlBytes(await gzipBytes(new TextEncoder().encode(text)))}`;
    const decodePlaintextFromHash = async (payload) => gunzipToText(fromB64UrlToBytes(payload));

    const updateCharCount = () => {
        const len = editor.value.length, urlLen = location.href.length;
        charCount.innerText = `${len} char${len !== 1 ? 's' : ''}`;
        urlCount.innerText = `URL: ${urlLen}`;
        urlCount.style.color = urlLen > 2000 ? '#ff4757' : '';
    };

    const updateStrengthMeter = () => {
        const pw = keyInput.value;
        status.style.color = '';
        if (!pw) { 
            strengthBar.style.width = '0'; 
            keyInput.style.borderColor = 'var(--border)'; 
            keyInput.style.boxShadow = 'none'; 
            if (status.innerText === "Weak key!" || status.innerText === "Ready") status.innerText = "Unencrypted";
            return; 
        }
        const s = [pw.length >= 8, pw.length >= 12, /[A-Z]/.test(pw), /[0-9]/.test(pw), /[^A-Za-z0-9]/.test(pw)].filter(Boolean).length;
        const isWeak = pw.length < 8;
        const color = isWeak ? '#ff4757' : (['#ff4757', '#ff4757', '#ffa502', '#2ed573', '#1e90ff'][s - 1] || '#ff4757');
        strengthBar.style.width = `${(s / 5) * 100}%`; strengthBar.style.background = color;
        keyInput.style.setProperty('border-color', color, 'important');
        keyInput.style.boxShadow = `0 0 5px ${color}`;
        
        if (isWeak) {
            status.innerText = "Weak key!";
            status.style.color = '#ff4757';
        } else if (status.innerText === "Weak key!" || status.innerText === "Secret key required") {
            status.innerText = "Ready";
        }
    };

    let syncTimer, lastDecryptionId = 0;
    const updateURL = () => {
        updateCharCount();
        clearTimeout(syncTimer);
        syncTimer = setTimeout(async () => {
            if (!editor.value || editor.value === "undefined") return;
            if (!isNonEmptyKey(keyInput.value)) {
                status.innerText = "Syncing (unencrypted)...";
                status.style.color = '';
                try {
                    const encoded = await encodePlaintextForHash(editor.value);
                    window.history.replaceState(null, '', `#${encoded}`);
                    updateCharCount();
                    status.innerText = "Synced (unencrypted)";
                    localStorage.removeItem('secredit_cache');
                } catch {
                    status.innerText = "Sync error";
                }
                return;
            }
            if (!isKeyStrongEnoughToEncrypt(keyInput.value)) {
                status.innerText = "Weak key!";
                status.style.color = '#ff4757';
                return;
            }
            status.innerText = "Encrypting...";
            try {
                const encrypted = await callWorker({ type: 'encrypt', text: editor.value, password: keyInput.value, iterations: KDF_ITERATIONS });
                if (!encrypted) throw 1;
                window.history.replaceState(null, '', `#${encrypted}`);
                updateCharCount();
                status.innerText = "Synced";
                localStorage.setItem('secredit_cache', JSON.stringify({ data: encrypted, iterations: KDF_ITERATIONS }));
            } catch { status.innerText = "Sync error"; }
        }, 500);
    };

    const performDecryption = async (data, password, iterations) => {
        if (!data) return;
        if (data.startsWith(PLAINTEXT_PREFIX)) {
            const currentId = ++lastDecryptionId;
            status.innerText = "Loading (unencrypted)...";
            status.style.color = '';
            try {
                const decoded = await decodePlaintextFromHash(data.slice(PLAINTEXT_PREFIX.length));
                if (currentId !== lastDecryptionId) return;
                editor.value = decoded;
                status.innerText = "Loaded (unencrypted)";
                updateCharCount();
                updateURL();
                return true;
            } catch {
                status.innerText = "Invalid data";
                return;
            }
        }
        if (!isNonEmptyKey(password)) {
            status.innerText = "Secret key required";
            status.style.color = '#ff4757';
            return;
        }
        const currentId = ++lastDecryptionId;
        status.innerText = "Decrypting...";
        const candidates = iterations ? [iterations] : [KDF_ITERATIONS, 100000, 300000, 1000000];

        for (const iter of candidates) {
            try {
                if (currentId !== lastDecryptionId) return;
                const dec = await callWorker({ type: 'decrypt', data, password: password || "", iterations: iter });
                if (currentId !== lastDecryptionId) return;
                editor.value = dec;
                status.innerText = "Decrypted";
                updateCharCount();
                updateURL();
                return true;
            } catch {}
        }
        if (currentId === lastDecryptionId) status.innerText = "Wrong key";
    };

    // --- Initialization & Events ---
    const isNonEmptyKey = (pw) => typeof pw === 'string' && pw.length > 0;
    const isKeyStrongEnoughToEncrypt = (pw) => typeof pw === 'string' && pw.length >= 8;

    document.querySelector('form.input-wrapper').addEventListener('submit', (e) => e.preventDefault());

    window.onload = async () => {
        const data = location.hash.substring(1);
        if (data) await performDecryption(data, keyInput.value);
        else {
            const cache = localStorage.getItem('secredit_cache');
            if (cache) {
                let cachedData, iterations;
                try {
                    ({ data: cachedData, iterations } = JSON.parse(cache));
                } catch {
                    localStorage.removeItem('secredit_cache');
                }
                if (!cachedData) return;
                status.innerText = "Load from cache?";
                status.style.cursor = "pointer";
                status.onclick = async () => {
                    if (!isNonEmptyKey(keyInput.value)) {
                        status.innerText = "Enter key to load cache";
                        return;
                    }
                    if (await performDecryption(cachedData, keyInput.value, iterations)) {
                        status.onclick = null;
                        status.style.cursor = "default";
                    }
                };
            }
        }
    };

    editor.oninput = () => updateURL();
    keyInput.oninput = () => {
        updateStrengthMeter();
        const data = location.hash.substring(1);
        if (data && !editor.value) performDecryption(data, keyInput.value);
        else if (editor.value) updateURL();
    };

    togglePass.onclick = () => {
        const isPass = keyInput.type === 'password';
        keyInput.type = isPass ? 'text' : 'password';
        togglePass.innerText = isPass ? 'üôà' : 'üëÅÔ∏è';
    };

    // --- Emoji Picker ---
    const emojis = ["üòä", "üòÄ", "üòÇ", "üòç", "ü§î", "üòé", "ü•∫", "üò¢", "üò≠", "üò≤", "üíÄ", "‚ù§Ô∏è", "‚úÖ", "üëç", "üëé", "üëá", "üëâ", "üî•", "‚ú®", "üöÄ", "üåü", "üéâ", "üíØ", "üëÄ", "üß†", "üí°", "üôè", "üëè", "üôå", "üí™"];
    emojis.forEach(emoji => {
        const btn = document.createElement('button');
        btn.className = 'emoji-item'; btn.innerText = emoji; btn.type = 'button';
        btn.onclick = (e) => {
            e.stopPropagation();
            const start = editor.selectionStart, end = editor.selectionEnd;
            editor.value = editor.value.slice(0, start) + emoji + editor.value.slice(end);
            editor.selectionStart = editor.selectionEnd = start + emoji.length;
            editor.focus(); updateURL(); emojiPopover.classList.remove('show');
        };
        emojiPopover.appendChild(btn);
    });
    emojiBtn.onclick = (e) => { e.stopPropagation(); emojiPopover.classList.toggle('show'); };
    document.onclick = (e) => { if (!emojiPopover.contains(e.target) && e.target !== emojiBtn) emojiPopover.classList.remove('show'); };

    // --- Actions ---
    exportBtn.onclick = async () => {
        if (!editor.value) return alert("Nothing to export");
        if (!isKeyStrongEnoughToEncrypt(keyInput.value)) return alert("Secret key required (8+ chars)");
        const encrypted = await callWorker({ type: 'encrypt', text: editor.value, password: keyInput.value, iterations: KDF_ITERATIONS });
        const blob = new Blob([JSON.stringify({ data: encrypted, iterations: KDF_ITERATIONS, v: 2 })], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `secret-${new Date().toISOString().slice(0, 10)}.secredit`;
        a.click();
    };

    importBtn.onclick = () => {
        const input = document.createElement('input');
        input.type = 'file'; input.accept = '.secredit';
        input.onchange = (e) => {
            const reader = new FileReader();
            reader.onload = async (re) => {
                let parsed;
                try {
                    parsed = JSON.parse(re.target.result);
                } catch {
                    status.innerText = "Invalid file";
                    return;
                }
                const { data, iterations } = parsed || {};
                if (typeof data !== 'string' || !data) {
                    status.innerText = "Invalid file";
                    return;
                }
                await performDecryption(data, keyInput.value, iterations);
            };
            reader.readAsText(e.target.files[0]);
        };
        input.click();
    };

    pasteBtn.onclick = async () => {
        try {
            const text = await navigator.clipboard.readText();
            if (!text) return;
            const start = editor.selectionStart, end = editor.selectionEnd;
            editor.value = editor.value.slice(0, start) + text + editor.value.slice(end);
            editor.selectionStart = editor.selectionEnd = start + text.length;
            editor.focus(); updateURL();
        } catch { status.innerText = "Paste failed"; }
    };

    const copy = (btn, text) => {
        if (!text) return;
        navigator.clipboard.writeText(text);
        const old = btn.innerText; btn.innerText = "‚úÖ";
        setTimeout(() => btn.innerText = old, 2000);
    };
    copyTextBtn.onclick = () => copy(copyTextBtn, editor.selectionStart !== editor.selectionEnd ? editor.value.slice(editor.selectionStart, editor.selectionEnd) : editor.value);
    copySecretBtn.onclick = () => location.hash.length > 1 ? copy(copySecretBtn, location.href) : alert("No content to share");

    clearBtn.onclick = () => {
        if (confirm("Clear text and start new document?")) {
            editor.value = ""; history.replaceState(null, '', location.pathname);
            localStorage.removeItem('secredit_cache');
            status.innerText = "Ready"; updateCharCount();
        }
    };

    // --- Find & Replace ---
    const fBar = $('find-replace-bar'), fIn = $('find-input'), rIn = $('replace-input');
    findBtn.onclick = () => { fBar.classList.toggle('hidden'); if (!fBar.classList.contains('hidden')) fIn.focus(); };
    $('close-find-btn').onclick = () => { fBar.classList.add('hidden'); editor.focus(); };

    const findNext = () => {
        const query = fIn.value; if (!query) return;
        let idx = editor.value.indexOf(query, editor.selectionEnd);
        if (idx === -1) idx = editor.value.indexOf(query);
        if (idx !== -1) { editor.focus(); editor.setSelectionRange(idx, idx + query.length); }
        else { const old = status.innerText; status.innerText = "Not found"; setTimeout(() => status.innerText = old, 1000); }
    };

    const replace = (all = false) => {
        const query = fIn.value, repl = rIn.value; if (!query) return;
        if (all) {
            editor.value = editor.value.split(query).join(repl);
            const old = status.innerText; status.innerText = "Replaced All"; setTimeout(() => status.innerText = old, 1000);
        } else {
            if (editor.value.slice(editor.selectionStart, editor.selectionEnd) === query) editor.setRangeText(repl, editor.selectionStart, editor.selectionEnd, 'select');
            findNext();
        }
        updateURL();
    };

    $('find-next-btn').onclick = findNext;
    $('replace-btn').onclick = () => replace();
    $('replace-all-btn').onclick = () => replace(true);
    [fIn, rIn].forEach(el => el.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); el === fIn ? findNext() : replace(); } });
    
    window.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
            e.preventDefault();
            fBar.classList.remove('hidden');
            fIn.focus();
        }
        if (e.key === 'Escape' && !fBar.classList.contains('hidden')) {
            fBar.classList.add('hidden');
            editor.focus();
        }
    });

    if ('serviceWorker' in navigator) navigator.serviceWorker.register('./sw.js').catch(() => {});
</script>
</body>
</html>
